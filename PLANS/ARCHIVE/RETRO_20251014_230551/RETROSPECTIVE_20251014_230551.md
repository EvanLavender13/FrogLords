# Retrospective: Oct 14, 2025

**Work Reviewed:** 3 feature iterations, 7 improvements  
**Date Range:** 20251014_010421 to 20251014_230307  
**Feature Iterations:** 2 completed, 1 deferred  
**Improvements:** 7 completed (4 Trivial Path, 3 Standard Path)

---

## Pattern Analysis

### Feature Iterations

**Planning Phase:**  
All three features (animation cycle stride consolidation, coyote/jump buffer, secondary motion joint limits) followed enhanced planning workflow. Two features completed PLAN_REVIEW (coyote/jump buffer, secondary motion joint limits), one skipped clarification as concrete and unambiguous (animation cycle stride). Planning quality was excellentâ€”coyote/jump buffer received 131-line feature spec with pseudocode, explicit variable names, and integration points. Animation cycle feature correctly identified phase discontinuity risk (60% certainty). Secondary motion feature boosted certainty from 60-70% to 75% based on proven infrastructure (debug tool pattern).

All features built on 90-100% certain foundations: animation system, locomotion, character controller, secondary motion springs. Dependency verification performed for all featuresâ€”no hidden coupling discovered.

**Implementation Phase:**  
Two features completed on first attempt (coyote/jump buffer, animation cycle stride). Both required in-session refinementâ€”expected and handled smoothly. Coyote/jump buffer completed cleanly per spec. Animation cycle stride exposed phase discontinuity (predicted risk), leading to architecture improvement: switched from passing `blended_stride` parameter to passing `phase` directly from locomotion. This simplified the design and eliminated recalculation instability.

Secondary motion joint limits deferred after implementation revealed fundamental knowledge gap. Multiple fix attempts (hard clamps, soft limits, axis flipping, absolute angle measurement) failed due to incomplete understanding of skeleton local coordinate frames. Small visual effect (secondary motion wobble) did not justify debugging complex quaternion/hierarchy issues. Correctly deferred until prerequisite knowledge exists (skeleton debugging tools, IK implementation forces solving same problems).

**Completion/Deferral:**  
Completion rate: 2/3 (67%). Animation cycle stride and coyote/jump buffer achieved all success criteria. Animation cycle stride delivered bonus improvement (phase reuse eliminated recalculation). Coyote/jump buffer delivered exactly as specifiedâ€”timing forgiveness extended jump eligibility without exploits.

Secondary motion joint limits deferral was disciplined: recognized missing prerequisites (understanding local coordinate frames), acknowledged knowledge gap, and correctly assessed ROI (small polish effect not worth quaternion debugging). Deferral captured technical insights for future work (local axes not mirrored as expected, quaternion decomposition complexity).

### Improvements

**Planning Phase:**  
Seven improvements completed: 4 Trivial Path (1-2 points), 3 Standard Path (3-8 points). Complexity estimates accurate: Trivial completions took 5-15 minutes, Standard paths took 20-60 minutes.

Standard path improvements showed excellent architectural alignment: reverse dependency fix (rendering -> character violation), restore missing debug visuals (regression from previous refactor), decouple character/camera (sideways dependency). All tagged Critical or High priority and addressed promptly.

Plan reviews caught two significant issues:
1. Restore debug visuals plan initially proposed premature abstraction (`mesh_geometry` struct with only 2 uses)â€”review recommended simplification, skipping Stage 1 abstraction
2. Extraction of pose mirroring logic switched from Euler angle approach (high risk) to simple struct swap (low risk) based on review feedback

**Execution Phase:**  
All seven improvements completed successfully (100% completion rate). Standard path improvements used staged execution effectively:
- Reverse dependency fix: 4 stages (define primitives, create generator, refactor debug_draw, bridge systems), each independently buildable
- Restore debug visuals: 2 stages (move generators to foundation, restore visuals), clean completion despite initial plan revision
- Decouple character/camera: 3 stages (update header, update implementation, update call site), localized to 3 files

Trivial path improvements completed faster than estimated:
- Simplify gait blending logic: ~5 minutes vs 1 point estimate (accurate)
- Decouple sokol from controller: ~10 minutes vs 2 points (accurate)
- Consolidate minor cleanup tasks: batched 4 tasks, ~20 minutes total vs 4 points

Pattern extraction followed rule-of-three discipline: pose mirroring logic extracted after observing duplication across walk/run cycles (4+ instances). One improvement (walk/run blend calculation) was correctly investigated and rejected in previous retrospectiveâ€”no false abstractions created.

**Scope & Discovery:**  
Scope discipline excellentâ€”no scope creep observed across any improvement. Two improvements discovered during feature work:
1. Animation cycle stride consolidation discovered during run gait blending (visual observation of missing cadence variation)
2. Secondary motion joint limits discovered during air locomotion weights (visual observation of hyperextension)

Architectural violation fixes completed in logical sequence: reverse dependency (rendering -> character) fixed first, then restoration of missing debug visuals (regression from that fix). This demonstrates how addressing one violation can surface related issues, handled correctly with staged improvements.

**Process Effectiveness:**  
Plan reviews proved highly valuable:
- Caught premature abstraction (mesh_geometry) before implementation
- Guided safer implementation approach (struct swap vs Euler angles for mirroring)
- One improvement (walk/run blend duplication) was correctly rejected in prior retrospectiveâ€”demonstrates plan validation preventing false work

Time estimates consistently accurate:
- Trivial path: 1-2 points = 5-15 minutes actual (Â±10% variance)
- Standard path: 3-8 points = 20-60 minutes actual (Â±20% variance)

Learning capture quality strong. All improvements documented "what worked well" and "what was harder than expected". Insights like "staged approach effective for complex refactors" and "plan reviews catch premature abstractions" provide concrete guidance.

**Completion/Deferral:**  
100% completion rate (7/7). No deferrals due to unexpected complexity. All improvements resolved within session. Restoration of debug visuals completed despite initial plan revisionâ€”demonstrates adaptability when plan review identifies issues.

### Cross-Cutting Observations

**Iteration Velocity:**  
Work completed in single day (Oct 14): 2 features + 7 improvements. Strong productivity without quality compromise. Features averaged 1-3 hours implementation time, improvements averaged 10-60 minutes. Self-test loops efficientâ€”visual validation in minutes for animation/debug work, gameplay validation in single test run for coyote/jump buffer.

**Knowledge Creation & Deferral Discipline:**  
Secondary motion joint limits deferral exemplifies mature knowledge management: recognized missing prerequisites (skeleton coordinate frame understanding), captured technical insights for future work (axes not mirrored, quaternion decomposition complexity), and assessed ROI correctly (small polish effect not worth quaternion debugging now). Feature will naturally resurface when IK implementation forces solving same transform hierarchy problems.

Animation cycle stride feature demonstrates learning from prior work: predicted phase discontinuity risk (60% certainty), discovered it during testing (as expected), and found cleaner solution (phase reuse) than originally planned. Pattern: when testing reveals instability, analyze mathematical operation (division by changing value) before adding complexity (smoothing).

**Architectural Alignment:**  
Strong focus on dependency cleanup:
- Reverse dependency (rendering -> character): Critical violation fixed
- Sideways dependency (character <-> camera): High priority, decoupled
- Platform dependency (controller -> sokol_app.h): Medium priority, isolated

All three architectural improvements created cleaner separation of concerns and reduced coupling. Pattern: architectural violations surfaced during feature work are captured to backlog and addressed in batch when foundations stabilize.

**Pattern Maturity:**  
Dual-reference spring-damper pattern now used 5 times successfully (landing spring, acceleration tilt, contact weight, walk_factor smoothing, secondary motion). No new instances added this iteration but existing uses remained stable. Surveyor wheel principle completedâ€”locomotion computes phase once, animation/debug systems reuse it. Single source of truth prevents recalculation instability.

**Testing Workflow:**  
Visual verification dominated testing (animation, debug visuals, character movement). Self-test loops short (minutes to hours) due to immediate visual feedback. Coyote/jump buffer feature used gameplay testing (jump at ledge edges, spam during bounce). Edge case validation (double-jump prevention, buffer execute on landing) confirmed in single test session.

No over-the-shoulder testing this iterationâ€”all work validated via self-test. Appropriate for polish/architectural work (not new gameplay mechanics).

---

## Synthesis: Keep / Stop / Start

### âœ… Keep Doing

**Planning Discipline:**
- **PLAN_REVIEW for Standard path improvements** catches premature abstractions and guides safer implementations (mesh_geometry abstraction caught, Euler -> struct swap guidance)
- **Concrete feature specs with pseudocode and variable names** enable unambiguous implementation (coyote/jump buffer 131-line spec, animation cycle stride with explicit integration points)
- **Certainty boosting based on proven infrastructure** accurately reflects reduced risk (secondary motion 60% -> 75% due to debug tool pattern)
- **Dependency verification before planning** prevents hidden coupling surprises (all features verified 90-100% certain foundations)

**Implementation & Testing:**
- **Staged execution for Standard path improvements** enables incremental validation and prevents integration issues (reverse dependency 4 stages, decouple character/camera 3 stages)
- **Visual verification loops for animation/debug work** provide rapid feedback and enable in-session iteration (animation cycle stride vibration fix same session)
- **Edge case validation during self-test** confirms robustness before completion (coyote/jump buffer: double-jump prevention, buffer execute on landing)

**Deferral & Knowledge Management:**
- **Disciplined deferrals with captured insights** prevent wasted effort and document prerequisites for future work (secondary motion joint limits: missing skeleton coordinate frame understanding, will resurface during IK)
- **ROI assessment for polish features** prevents perfectionism on low-impact visuals (secondary motion wobble not worth quaternion debugging)
- **Learning capture in reflections** documents what worked/didn't for future reference (animation cycle stride: analyze mathematical operation before adding complexity)

**Architectural Focus:**
- **Batched architectural violation fixes** after feature work stabilizes prevent refactor conflicts (reverse dependency, decouple character/camera, decouple sokol)
- **Staged architectural refactors** with independent build validation prevent integration failures (reverse dependency: each stage buildable)
- **Pattern consolidation when proven** creates reusable abstractions (pose mirroring after 4+ instances, surveyor wheel phase reuse)

### ðŸ›‘ Stop Doing

**Nothing identified.** This iteration demonstrated mature workflow execution:
- No scope creep observed
- No premature abstractions created (plan review caught one, preventing implementation)
- No architectural violations introduced
- No false pattern extractions (rule-of-three discipline maintained)
- No wasted deferral cycles (secondary motion correctly assessed as ROI-negative)

### ðŸ†• Start Doing

**Skeleton Coordinate Frame Understanding (Technical Debt):**
- **Build skeleton debugging/visualization tools** before attempting per-bone axis-dependent features (IK, joint limits, targeted limb control)
  - Rationale: Secondary motion joint limits revealed fundamental gapâ€”don't understand local coordinate frames well enough to apply rotations confidently
  - Tooling needs: world-space visualization of rotation axes per joint, local->world->local transform chain visualization, validation that mirrored joints use symmetric axes
  - Trigger: Before starting IK implementation or any feature requiring per-bone rotation control

**Quaternion Math Validation (Process):**
- **Test quaternion decomposition/composition in isolation** before integrating into gameplay features
  - Rationale: Attempted absolute angle measurement for soft limits revealed we can't reliably decompose rotations around arbitrary axes in local bone space
  - Pattern: When feature requires quaternion math beyond basic interpolation (decomposition, axis extraction, signed angles), validate in standalone test first
  - Examples: Measuring joint bend angles, extracting rotation around specific axis, converting quaternion to Euler for soft limits

**Math Operation Stability Analysis (Implementation):**
- **When testing reveals instability, analyze the mathematical operation** before adding smoothing/damping complexity
  - Rationale: Animation cycle stride initially passed `blended_stride` and recalculated phase, causing vibration. Attempted dual-reference smoothing (symptom fix), but root cause was division by changing value. Phase reuse (upstream already computed correctly) solved it elegantly.
  - Pattern: Instability often signals redundant calculation or missing upstream data. Check "what does upstream already give us correctly?" before adding complexity.
  - Applies to: Any derived state that vibrates/oscillates unexpectedly during smooth transitions

**Architectural Refactor Sequencing (Planning):**
- **When fixing architectural violations, check for related violations** before finalizing plan
  - Rationale: Reverse dependency fix (rendering -> character) created regression (missing debug visuals), which was immediately addressed with second improvement (restore visuals). Could have planned both together.
  - Pattern: If refactor moves functionality between layers (extraction, inversion), check if dependent features exist in old location that will break. Plan restoration/migration together.
  - Not a failure this iteration (both completed cleanly), but opportunity to reduce intermediate broken states.

---

## Proposed Workflow Changes

### [DOC] Update AGENTS.md - Add Quaternion Math Validation Guideline

**Section:** Development Directives -> Do/Don't lists

**Addition:**
```markdown
Do:
- Test quaternion decomposition/composition in isolation before integrating (measure angles, extract axes, convert to Euler)
- Analyze mathematical operations causing instability before adding smoothing (division by changing value, redundant calculations)
- Check "what does upstream already give us correctly?" when derived state vibrates unexpectedly
```

**Rationale:** Secondary motion joint limits and animation cycle stride both encountered math-related issues (quaternion decomposition failure, phase recalculation instability). Explicit guidance prevents repeating these patterns.

---

### [DOC] Update RETROSPECTIVE.md - Add "Skeleton Coordinate Frame Prerequisites" to Common Deferral Triggers

**Section:** Pattern Analysis -> Feature Iterations -> Completion/Deferral (example text)

**Addition to examples:**
```markdown
**Skeleton coordinate frame understanding gaps:**
- Features requiring per-bone axis-dependent rotations (IK, joint limits, targeted limb control)
- Missing prerequisites: skeleton debugging/visualization tools, understanding of local->world transform chain
- Reconsideration trigger: After building skeleton debugging tools or during IK implementation (forces solving same problems)
```

**Rationale:** Secondary motion joint limits deferral revealed a common blocker for animation features. Documenting this as a known prerequisite gap helps future planning (don't attempt joint-specific rotation features without coordinate frame understanding).

---

### [EXPERIMENT] Architectural Refactor Staging - Plan Restoration Migrations Together

**Description:** When planning architectural refactors that move functionality between layers, explicitly check for dependent features in the old location and plan their restoration/migration in the same improvement (as additional stages) rather than as separate follow-up work.

**Trial Period:** Next 2-3 architectural refactors

**Success Criteria:**
- No intermediate broken states (missing features during refactor)
- Reduced total improvement count (restoration folded into original refactor)
- No increase in complexity or planning time

**Rationale:** Reverse dependency fix + restore debug visuals could have been planned together (both known during plan phase). This experiment tests whether batching reduces churn without increasing risk.

**Measurement:** Track whether follow-up "restore X" improvements are needed after architectural refactors. If zero over 2-3 refactors, codify pattern. If still occurring, current two-stage approach (fix violation, restore features) is correct.

---

## Certainty Calibration

### Feature: Animation Cycle Stride Consolidation

**Predicted Certainty:** 60%  
**Actual Outcome:** Completed with in-session refinement (phase reuse fix)

**Variance Analysis:**
- Predicted 60% due to "may require retuning stride lengths" and "could expose phase discontinuity" risks
- Phase discontinuity occurred as predictedâ€”risk assessment accurate
- Fix was simpler and better than original plan (phase reuse vs stride parameter passing)
- Implementation risk lower than predictedâ€”refinement improved design

**Calibration:** Prediction accurate. When feature exposes predicted risk but finds cleaner solution during testing, that's expected iteration, not under-estimation.

---

### Feature: Coyote Time + Jump Buffer

**Predicted Certainty:** 85%  
**Actual Outcome:** Completed on first attempt, all success criteria met

**Variance Analysis:**
- Predicted 85% based on widely-used pattern (Celeste, Hollow Knight) with well-understood implementation
- Primary risk: "tuning window durations to feel natural without being exploitable"
- Feature completed exactly as specified with no tuning iterations required (window sizes worked first try)
- No architectural novelty, purely parameter-drivenâ€”accurate assessment

**Calibration:** Slightly over-estimated risk. Standard timing patterns with concrete specs (120-150ms windows, explicit edge cases) execute closer to 90-95% certainty. Adjust future similar features (input buffering, timing windows) +5-10% certainty.

---

### Feature: Secondary Motion Joint Limits

**Predicted Certainty:** 75%  
**Actual Outcome:** Deferred due to missing prerequisites (skeleton coordinate frame understanding)

**Variance Analysis:**
- Predicted 75% (boosted from 60-70% base due to "builds on 100% stable secondary motion infrastructure, debug tool pattern, zero gameplay risk")
- Base 60-70% included risk: "tuning ranges to feel natural (iteration, not architecture)"
- Actual blocker: fundamental gap in skeleton local coordinate frame understanding, not tuning complexity
- Certainty boost was incorrectâ€”infrastructure stability doesn't compensate for missing domain knowledge (quaternion math in local bone space)

**Calibration:** Over-estimated certainty. Infrastructure stability (secondary motion springs working) is different from domain knowledge (understanding skeleton coordinate frames for per-bone rotations). When feature requires axis-dependent rotations or quaternion decomposition, check: "Do we understand the local coordinate system well enough to apply rotations confidently?" If no visualization/debugging tools exist for that domain, cap certainty at 50-60% regardless of infrastructure stability.

**Learning:** "Debug tool pattern" certainty boost applies when tool uses existing visualization primitives (lines, spheres, text). Does NOT apply when tool requires new domain understanding (local bone axes, quaternion decomposition around arbitrary axes). Refine certainty heuristic: stable infrastructure + proven visualization primitives = +10-15% boost. Stable infrastructure + new domain math = no boost (novel math risk dominates).

---

## Process Effectiveness Metrics

**Feature Completion Rate:** 67% (2/3)  
**Improvement Completion Rate:** 100% (7/7)  
**Deferrals with Captured Insights:** 100% (1/1 - secondary motion joint limits documented prerequisites and technical insights)

**Planning Quality:**
- Plan reviews caught 1 premature abstraction (mesh_geometry)
- Plan reviews guided 1 safer implementation (struct swap vs Euler angles)
- Zero false work started (all completed improvements addressed real issues)

**Time Estimate Accuracy:**
- Trivial path: Â±10% variance (5-15 min actual vs 1-2 point estimates)
- Standard path: Â±20% variance (20-60 min actual vs 3-8 point estimates)
- Features: Within session (1-3 hours), no multi-day overruns

**Architectural Health:**
- 3 architectural violations fixed (reverse dependency, sideways dependency, platform coupling)
- 0 new violations introduced
- Dependency flow cleaner post-improvements (rendering/character/camera decoupled)

**Knowledge Capture:**
- All completed work has reflection sections documenting learnings
- Deferred work captured missing prerequisites for future planning
- Pattern maturity tracked (dual-reference springs: 5 uses, surveyor wheel: completed)

---

## Next Steps

1. **Archive this retrospective:** Move to `PLANS/ARCHIVE/RETRO_<timestamp>/`
2. **Update AGENTS.md:** Add quaternion math validation guideline (proposed change above)
3. **Update RETROSPECTIVE.md:** Add skeleton coordinate frame prerequisites example (proposed change above)
4. **Trial architectural refactor staging:** On next 2-3 refactors, plan restoration migrations together (experiment)
5. **Adjust certainty heuristic for domain knowledge gaps:** When feature requires quaternion decomposition/axis-dependent rotations without visualization tools, cap at 50-60% certainty regardless of infrastructure stability

---

## Final Notes

This iteration demonstrated mature workflow execution: strong planning discipline, effective staged execution, disciplined deferrals, and productive architectural cleanup. The secondary motion joint limits deferral was particularly well-handledâ€”recognized knowledge gap, captured insights, assessed ROI correctly. Animation cycle stride feature showed learning from prior work (predicted instability risk, found cleaner solution during testing).

Main improvement opportunity: build skeleton debugging/visualization tools before attempting more animation features requiring per-bone control (IK, joint limits). Current quaternion keyframe blending works as black box, but per-bone rotations expose incomplete understanding of local coordinate frames.

Feature/improvement interleaving worked well: features discovered architectural issues (reverse dependencies), improvements cleaned them up in batch after stabilization. No refactor conflicts observed.

Overall velocity high (2 features + 7 improvements in single day) without quality compromise. Time estimates accurate, scope discipline maintained, no false abstractions created.
