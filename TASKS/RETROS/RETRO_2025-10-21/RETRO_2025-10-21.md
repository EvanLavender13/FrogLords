# Retrospective: 2025-10-21

**11 plans analyzed. 6 patterns found.**

---

## Patterns (≥3 occurrences)

**Process Violations:**
1. Documentation-Code Divergence (×3) - CAMERA_LOCK_ITERATION_1, CAMERA_LOCK_ITERATION_2, CAMERA_LOCK_ITERATION_3
   - Plans describe intended design, implementation evolves during graybox, docs not synchronized
   - Root cause: Plans written before code, not updated to match reality

2. Excessive Process for Trivial Changes (×3) - controller_state_audit, uninitialized_buffers, variable_scope
   - Trivial refinements (-4 LOC, +2 LOC, +6 LOC) with full plan templates
   - Root cause: Template overhead doesn't scale down for single-line fixes

3. Static Analyzer False Positives (×3) - controller_state_audit, uninitialized_buffers, variable_scope
   - cppcheck/clang-tidy flags legitimate patterns (temporal dependencies, sokol handle init, write-only debug state)
   - All three required human judgment to distinguish real violations from tool noise

**Architectural Patterns:**
4. Physics Responsibility Placement (×3) - CAR_CONTROL_ITERATION_1 (violated), CAR_CONTROL_ITERATION_2 (fixed), CAMERA_LOCK all iterations (correct)
   - Iteration 1: Heading integration in game_world (composition layer) violated orthogonality
   - Iteration 2: Moved to controller (physics primitive) - correct layering
   - Camera lock: Direction derivation in composition, positioning in primitive - correct from start

**Workflow Successes:**
5. ITERATE/VALIDATE Cycle Caught Issues (×5) - All system plans caught violations through Codex review
   - CAR_CONTROL: Caught physics layer violation, dead code, comment drift
   - CAMERA_LOCK: Caught unused fields, inline trig inconsistency, doc-code drift
   - Workflow prevented shipping principle violations

6. Documentation-Only Iterations (×1) - CAMERA_LOCK_ITERATION_3
   - Created full iteration for docs-only changes
   - Excessive overhead for non-code changes

**Deferred (<3 occurrences):**
1. Comment Drift (×2) - controller.h claims heading integrated in apply_input (CAR_CONTROL_ITERATION_1), line number references stale (CAR_CONTROL_ITERATION_2)

---

## Important Ideas from Plans

**Unconditional State Updates Prevent Staleness** (CAR_CONTROL_ITERATION_2):
- Heading always integrates (even in FREE_STRAFE mode) eliminated stale state without complexity
- Composition layer selects when to use it, primitive always maintains it
- Pattern: Update unconditionally, consume conditionally

**Pure Function Composability** (CAMERA_LOCK all iterations):
- Camera lock works instantly without needing its own spring—smoothness comes from upstream orientation system for free
- Direction input makes function composable with any directional source (velocity, path tangent, look-ahead)
- Pattern: Derive from existing smoothed state instead of adding new smoothing

**Explicit Semantic Typing** (CAR_CONTROL_ITERATION_2):
- Separation of `turn_input` from `move_direction.x` created cleaner API than expected
- Dual-purpose parameters hide intent; explicit struct fields clarify
- Pattern: Make semantic differences explicit in type structure

**Static Analysis Integration** (variable_scope):
- Inline suppressions (`// cppcheck-suppress variableScope`) with explanations for false positives
- `--inline-suppr` flag enables per-line control
- Pattern: Use suppressions as documentation of semantic requirements tools can't understand

---

## Actions

**Context Files (COMMON):**
- Create `TASKS/CONTEXT/STATIC_ANALYSIS.md` for false positive handling patterns
- Inject into CLAUDE.md: No (use when refinement involves analyzer warnings)

**Workflow Updates (COMMON):**
- `TASKS/REFINE/SELECT.md`: Add "Path A (trivial) = Skip plan, commit directly" guideline
- `TASKS/ITERATE.md`: Add "Documentation-only changes do not require new iterations - edit system doc directly"
- `TASKS/VALIDATE.md`: Note that doc-code divergence during graybox is acceptable (code is truth, docs are history)

**Backlog Updates (COMMON):**
- Add refinement: Comment drift cleanup (controller.h, camera code)
- Pattern: Write-only debug state is acceptable if reactive systems consume it

**PRINCIPLES.md Updates (RARE - only if principle itself is wrong):**
- None (all patterns are implementation/process details, not philosophical)

---

## Summary

- Patterns: 6 (3 process violations, 2 architectural, 1 workflow success)
- Important Ideas: 4 (unconditional updates, pure function composability, semantic typing, static analysis integration)
- Actions: 1 context file, 3 workflow updates, 1 backlog item
- Execute: Context file first, then workflow updates
- Work status: 8 completed (3 refinements, 2 systems with 5 iterations), 0 deferred/rejected
- Workflow status: ITERATE/VALIDATE cycle successfully caught all principle violations before merge. Process overhead too heavy for trivial changes. Documentation-only iterations wasteful.

---
